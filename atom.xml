<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://DX990307.github.io</id>
    <title>Daoxuan Xu&apos;s Homepage</title>
    <updated>2023-10-13T00:25:04.173Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://DX990307.github.io"/>
    <link rel="self" href="https://DX990307.github.io/atom.xml"/>
    <subtitle>çºµä½¿å›°é¡¿éš¾è¡Œï¼Œäº¦å½“ç ¥ç ºå¥‹è¿›</subtitle>
    <logo>https://DX990307.github.io/images/avatar.png</logo>
    <icon>https://DX990307.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Daoxuan Xu&apos;s Homepage</rights>
    <entry>
        <title type="html"><![CDATA[è¯»ä¹¦ç¬”è®°--è®¡ç®—æœºç»„æˆä¸è®¾è®¡ ç¡¬ä»¶è½¯ä»¶æ¥å£ risc-v ç¬¬äºŒç« ]]></title>
        <id>https://DX990307.github.io/post/du-shu-bi-ji-ji-suan-ji-zu-cheng-yu-she-ji-ying-jian-ruan-jian-jie-kou-risc-v-di-er-zhang/</id>
        <link href="https://DX990307.github.io/post/du-shu-bi-ji-ji-suan-ji-zu-cheng-yu-she-ji-ying-jian-ruan-jian-jie-kou-risc-v-di-er-zhang/">
        </link>
        <updated>2023-10-12T10:33:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="211-æŒ‡ä»¤ä¸å¹¶è¡Œæ€§åŒæ­¥">2.11 æŒ‡ä»¤ä¸å¹¶è¡Œæ€§ï¼šåŒæ­¥</h2>
<p>åœ¨å¹¶è¡Œå·¥ä½œæ—¶ï¼Œä»»åŠ¡ä¹‹é—´é€šå¸¸éœ€è¦åä½œã€‚åœ¨åä½œä¸­ï¼Œä¸€ä¸ªä»»åŠ¡Aæ‰€éœ€è¦çš„å€¼å¯èƒ½ä¸ºå¦å¤–ä¸€ä¸ªä»»åŠ¡Bæ‰€äº§ç”Ÿã€‚ä¸ºäº†é¿å…ä»»åŠ¡Aåœ¨æ‰§è¡Œæ—¶ä»»åŠ¡Bçš„ç»“æœè¿˜æ²¡æœ‰åˆ°æ‰€äº§ç”Ÿçš„__æ•°æ®ç«äº‰__ï¼Œä»»åŠ¡ä¹‹é—´éœ€è¦è¿›è¡ŒåŒæ­¥ã€‚<br>
<strong>æ•°æ®ç«äº‰(data race)</strong> : å¦‚æœæ¥è‡ªä¸¤ä¸ªä¸åŒçš„å¿åŸçš„è®¿å­˜è¯·æ±‚è®¿é—®ç»Ÿä¸€ä½ç½®ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªæ—¶å†™ï¼Œ ä¸”è¿ç»­å‡ºç°ï¼Œé‚£ä¹ˆè¿™ä¸¤æ¬¡å­˜å‚¨è®¿é—®å½¢æˆäº†æ•°æ®ç«äº‰ã€‚<br>
åŒæ­¥æœºåˆ¶æ˜¯ç”±lockå’Œunlockäº§ç”Ÿäº’æ–¥æ‰€å®ç°çš„ï¼Œlockå’Œunlockå¯ä»¥åˆ›å»ºåªæœ‰å•ä¸ªå¤„ç†å™¨å¯ä»¥æ“ä½œçš„åŒºåŸŸï¼Œç§°ä¹‹ä¸ºäº’æ–¥åŒºã€‚åœ¨å¤šå¤„ç†å™¨ä¸­ï¼Œå®ç°åŒæ­¥æ‰€éœ€çš„æ—¶ä¸€ç»„ç¡¬ä»¶åŸè¯­ï¼Œåœ¨å†…å­˜å•å…ƒè¯»å–å’Œå¸ä¹³ä¹‹é—´ä¸æ’å…¥ä»»ä½•å…¶ä»–æ“ä½œçš„æ–¹å¼å®ç°åŒæ­¥ï¼Œè¿™ç§æ–¹å¼ç§°ä¹‹ä¸ºåŸå­ï¼ˆAtomï¼‰ã€‚<br>
<strong>E.g. åŸå­äº¤æ¢</strong><br>
åŸå­äº¤æ¢æ˜¯æ„å»ºåŒæ­¥æœºåˆ¶çš„å…¸å‹æ“ä½œï¼Œå°†å¯„å­˜å™¨å’Œå­˜å‚¨å™¨ä¸­çš„å€¼è¿›è¡Œäº¤æ¢ã€‚<br>
æˆ‘ä»¬è§„å®š<br>
* 0 è¡¨ç¤ºå˜é‡é”å¯ç”¨<br>
* 1 è¡¨ç¤ºå˜é‡é”è¢«å ç”¨<br>
é‚£ä¹ˆ<br>
åœºæ™¯1<br>
* å¤„ç†å™¨Aé€šè¿‡è®¾ç½®å¯„å­˜å™¨ç›¸å¯¹åº”åœ°å€Açš„å€¼æ¥è®¾ç½®å˜é‡é”<br>
* å¤„ç†å™¨Båœ¨è®¿é—®è¿™ä¸ªåœ°å€Aä¹‹å‰å…ˆæ‰§è¡Œä¸€æ®µç¨‹åºæ¥æ£€æŸ¥å¯„å­˜å™¨ä¸­çš„å€¼æ¥åˆ¤æ–­æ˜¯å¦è¢«å ç”¨<br>
* å½“æœªè¢«å ç”¨æ—¶ï¼Œç¨‹åºè¿”å›0ï¼Œå¤„ç†å™¨Bå¯ä»¥æ­£å¸¸è®¿é—®è¿™ä¸€æ®µåœ°å€æ‰€å­˜å‚¨çš„å€¼<br>
* å½“è¢«å ç”¨æ—¶ï¼Œç¨‹åºè¿”å›1ï¼Œè¯´æ˜è¿™ä¸€æ®µåœ°å€æ‰€å­˜å‚¨çš„å€¼æ­£åœ¨è¢«Aå ç”¨ï¼Œå½“Aå¤„ç†å®Œåï¼Œå°†å˜é‡é”ç½®0ï¼Œå¤„ç†å™¨Bå¯ä»¥æ­£å¸¸è®¿é—®ã€‚<br>
åœºæ™¯2<br>
* å½“å¤„ç†å™¨Aå’ŒBåŒæ—¶æƒ³è¦è®¿é—®ä¸€æ®µåœ°å€æ—¶ï¼Œåªæœ‰ä¸€ä¸ªå¤„ç†å™¨å¯ä»¥å¾—åˆ°è¿™æ®µåœ°å€ä¸­å†…å®¹çš„è®¿é—®æƒï¼Œå¦å¤–ä¸€ä¸ªéœ€è¦ç­‰å¾…ã€‚<br>
<strong>æŒ‡ä»¤å¯¹</strong><br>
æŒ‡ä»¤å¯¹å®ç°åŸå­æ“ä½œçš„æ–¹å¼æ˜¯åœ¨æŒ‡ä»¤å¯¹æ‰§è¡Œæ—¶ï¼Œä»»ä½•å…¶ä»–æŒ‡ä»¤çš„æ‰§è¡Œéƒ½åœ¨å…¶å‰æˆ–å…¶åï¼ˆæ¢å¥è¯è¯´åœ¨æ‰§è¡Œè¿™ä¸ªæŒ‡ä»¤å¯¹æ—¶ï¼Œæ²¡æœ‰å…¶ä»–çš„æ“ä½œå¯¹å…¶è¿›è¡Œå¹²æ‰°ï¼‰ã€‚ä¸€èˆ¬åœ¨æŒ‡ä»¤å¯¹çš„ç¬¬äºŒæ¡æŒ‡ä»¤ä¸­ä¼šè¿”å›ä¸€ä¸ªå€¼æ¥è¡¨ç¤ºè¿™ä¸ªæŒ‡ä»¤å¯¹æ˜¯å¦æ—¶åŸå­æ‰§è¡Œçš„ã€‚<br>
RISC-Vä¸­ç”±load-reserved(<code>lr.d</code>)å’Œstore-conditional(<code>sc.d</code>)çš„ç‰¹æ®ŠæŒ‡ä»¤å®ç°ï¼Œåœ¨<code>lr.d</code>æ‰€æŒ‡å®šçš„åœ°å€åœ¨<code>sc.d</code>æ‰§è¡Œå‰æ˜¯ä¸ä¼šè¢«æ›´æ”¹çš„ã€‚</p>
<pre><code>again:   lr.d   x10,    (x20) 
           sc.d   x11,   x23,   (x20)
           bne  x11,    x0,     again
           addi x23,    x10,    0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MPI Send/Recv]]></title>
        <id>https://DX990307.github.io/post/mpi-sendrecv/</id>
        <link href="https://DX990307.github.io/post/mpi-sendrecv/">
        </link>
        <updated>2023-03-06T13:43:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mid-term-code-review">Mid-term Code review</h1>
<h2 id="module-2a">Module 2a</h2>
<h3 id="hello-worldmpi">Hello world(MPI)</h3>
<p>assuse the total number of the rank is 8.</p>
<pre><code class="language-c">#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
void main(int argc, char *argv[])
{
    int RankID, NumOfRanks;
    MPI_Init(&amp;argc, &amp;argv);
    MPI_Comm_Rank(MPI_Comm_WORLD, &amp;RankID);
    MPI_Comm_Size(MPI_Comm_WORLD, &amp;NumOfRanks);
    printf(&quot;I am rank %d, total %d&quot;, RankID, NumOfRanks);
    MPI_Finalize();
    return 0;
}
</code></pre>
<p>The out of the code graph is</p>
<pre><code>I am rank 0, total 8
I am rank 3, total 8
...
</code></pre>
<h3 id="mpi_sendmpi_recv-example">MPI_send/MPI_Recv Example</h3>
<pre><code class="language-c">#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MASTER = 0; // define the master rank is rank 0;
int main(int argc, char *argv[])
{
    int RankID, NumOfRanks; // define rankid for the rank itself, and the total number of the ranks.
    int source, dest; // define sender(source) and receiving rank(daest)
    int tag = 0; //tag of message buffer.
    char buffer[100];
    MPI_Status status;

    MPI_Init(&amp;argc, &amp;argv);
    MPI_Comm_Rank(MPI_Comm_WORLD, &amp;RankID);
    MPI_Comm_Size(MPI_Comm_WORLD, &amp;NumOfRanks);
    if(RankID != 0)
    {
        sprintf(buffer, &quot;Greetings from %d&quot;, RankID); // store &quot;Gretting from RankID&quot; into buffer;
        dest = MASTER;
        counts = strlen(buffer) + 1; // total counts of the char in buffer
        MPI_Send(buffer, counts, MPI_CHAR, dest, tag, MPI_COMM_WORLD);
    }
    else
    {
        for(source = 1; source &lt; NumOfRanks; source++)
        {
            MPI_Recv(buffer, 100, srouce, tag, MPI_COMM_WORLD, &amp;status);
            printf(&quot;%s\n&quot;, buffer);
        }
    }
    return 0;
}
</code></pre>
<p>The output should be</p>
<pre><code>Greetings from 1
Greetings from 2
Greetings from 3
Greetings from 4
Greetings from 5
Greetings from 6
Greetings from 7
</code></pre>
<p>revisit the code of <code>MPI_Send</code> and <code>MPI_Recv</code><br>
<strong>MPI_Send</strong></p>
<pre><code class="language-c">MPI_Send(void *buffer, 
         int count, 
         MPI_DataType, MPI_CHAR
         int dest
         int tag
         MPI_COMM_WORLD);
</code></pre>
<p>buffer: the buffer that will be sent;</p>
<p>count: the total number of counts that will be sent;</p>
<p>MPI_DataType : the type that will be sent. E.g. MPI_INT, MPI_DOUBLE;</p>
<p>dest: The destination of the Send function;</p>
<p>tag: message tag, that is used to be distinguish messages that are sent by the same sender simultaneously.<br>
When A sends a message to B, A will package the message and send the message to the rank that processes B. When B receive the message successfully, it will send back a message to tell A that &quot;I receive the message from you successfully&quot;. After that, A will execute other operations. Sometimes, A will send several messages to B simultaneously. B needs to use parameter &quot;tag&quot; to distinguish messages sent by A.</p>
<p>MPI_COMM_WORLD: the zone that processor located in.</p>
<p><strong>MPI_Recv</strong></p>
<pre><code class="language-c">MPI_Recv(
    void *buffer,
    int count,
    MPI_DataType, MPI_CHAR,
    int source,
    int tag,
    MPI_COMM_WORLD,
    &amp;status
);
</code></pre>
<p>&amp;status <sup>[1]</sup>: MPI_status is a kind of data structure, which includes</p>
<ol>
<li>the rank of the sender, the rank of the sender is stored in the <code>MPO_SOURCE</code> element of the structure. That is if we declare an <code>MPI_Status status</code> variable, the rank can be accessed with <code>status.MPI_SOURCE</code>.</li>
<li>The tag of the message. The tag of the message can be accessed by the <code>MPI_TAG</code> element of the structure.</li>
<li>The length of the message. The length of the message does not have a predefined element in the status structure. Instead, we have to find out the length of the message with <code>MPI_Get_count</code>.</li>
</ol>
<h3 id="another-example-of-mpi_sendmpi_recv">Another Example of MPI_Send/MPI_Recv</h3>
<p>matrix multiplication</p>
<p>The main code of the matrix multiplication</p>
<pre><code class="language-c">for(i = 0; i&lt;NRA; i++)
    for(j = 0; j&lt;NCB; j++)
    {
        c[i][j] = 0;
        for (k = 0; k &lt; NCA; k++)
            c[i][j] = c[i][j] + a[i][k] * b[k][j];
    }
</code></pre>
<p>MPI code (main code) Use a <strong>master/worker style</strong> architecture</p>
<p>Master rank perform coodrination:</p>
<ul>
<li>Distributes rows of Martix A</li>
<li>Send all of Martix B to each worker ranks.</li>
</ul>
<p>Workers</p>
<ul>
<li>On its own data to create a partical C martix</li>
<li>Sends partical result back to master rank</li>
</ul>
<pre><code class="language-c">#define MASTER = 0; // assume we have 8 ranks
#define FROM_MASTER = 1;
#define FROM_WORKER = 2;
int main(int argc, char **argv)
{
    double NRA = atof(argv[1]);
    double NCA_NRB = atof(argv[2]);
    double NCB = atof(argv[3]);
    double A[NRA][NCA_NRB],
           B[NCA_NRB][NCB],
           C[NRA][NCB];
    int rankID,
        numOfRanks,
        averow,
        extra,
        offset
        mtype;

    offset = 0;
    MPI_Init(&amp;argc, &amp;argv);
    MPI_COMM_RANK(MPI_COMM_WORLD, &amp;rankID);
    MPI_COMM_SIZE(MPI_COMM_WORLD, &amp;numOfRanks);

    /*Master Operation*/
    if (rankID == MASTER)
    {
        averow = NRA/numOfRanks;
        extra  = NRA%numOfRanks;

        mtype = FROM_MASTER;

        ... code of generate matrix a and b...

        for(int dest = 1; dest &lt; numOfRanks; dest++)
        {
            int row = (dest &lt;= extra) ? averow + 1 : averow;
            printf(&quot;Sending %d row to rask %d\n&quot;, row, dest);
            MPI_Sent(&amp;offset, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD);
            MPI_Sent(&amp;row, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD);
            MPI_Sent(&amp;A[offset][0], row*NCA_NRB, MPI_DOUBLE, dest, mtype, MPI_COMM_WORLD);
            MPI_Sent(&amp;B, NCA_NRB*NCB, MPI_DOUBLE, dest, mtype, MPI_COMM_WORLD);
            offset += row;
        }

        mytype = FROM_WORKER;
        for (int dest = 1; dest &lt; numOfRanks; dest++)
        {
            printf(&quot;receive %d row to rask %d\n&quot;, row, dest);
            MPI_Recv(&amp;offset, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD, &amp;status);
            MPI_Recv(&amp;row, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD, &amp;status);
            MPI_Recv(&amp;C[offset][0], row*NCB, MPI_DOUBLE, dest, mtypeï¼Œ MPI_COMM_WORLD, &amp;status);
        }

        
    }

    if ï¼ˆrankID != MASTERï¼‰
    {
        mtype = FROM_MASTER;
        MPI_Recv(&amp;offset, 1, MPI_INT, MASTER, mtype, MPI_COMM_WORLD, &amp;status);
        MPI_Recv(&amp;row, 1, MPI_INT, MASTER, mtype, MPI_COMM_WORLD, &amp;status);
        MPI_Recv(&amp;A[offset][0], row*NCA_NRB, MPI_INT, MASTER, mtype, MPI_COMM_WORLD, &amp;status);
        MPI_Recv(&amp;B, NCB*NCA_NRB, MPI_INT, MASTER, mtype, MPI_COMM_WORLD, &amp;status);

        ... code of computing the matrix multiplication ...

        mtype = FROM_WORKER;
        MPI_Send(&amp;offset, 1, MPI_INT, MASTER, mtype, MPI_COMM_WORLD);
        MPI_Send(&amp;row, 1, MPI_INT, MASTER, mtype, MPI_COMM_WORLD);
        MPI_Send(&amp;C[offset][0], row*NCB, MPI_INT, MASTER, mtype, MPI_COMM_WORLD);
    }
}
</code></pre>
<h2 id="reference">Reference</h2>
<p>[1]:<a href="https://mpitutorial.com/tutorials/dynamic-receiving-with-mpi-probe-and-mpi-status/">MPI Tutorial</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MMU(memory management unit)å­¦ä¹ ç¬”è®°V0.0.0]]></title>
        <id>https://DX990307.github.io/post/mmumemory-management-unitxue-xi-bi-ji-v000/</id>
        <link href="https://DX990307.github.io/post/mmumemory-management-unitxue-xi-bi-ji-v000/">
        </link>
        <updated>2023-03-02T08:29:34.000Z</updated>
        <content type="html"><![CDATA[<p>Previously, I wanted to learn the structure of the memory management unit in <em>computer architecture -- a quantitative approach</em> comperhensively. However, I cannot find a chapter that inturduce MMU in the book. In that case, I read some materials on the Internet and try to write something to record what I am learnt from the wikipedia and other documents.</p>
<h3 id="brief-introduction-about-memory-management-unitmmu">Brief introduction about memory management unit(MMU)</h3>
<p>MMU(memory management unit), also called PMMU (paged memory management unit). It is responsible for the translation of virtual addresses to physical addresses. MMUs also have some functions such as memory protection, cache control, bus arbitration etc.</p>
<p>In different computer architecture, the place of the MMU in the computer architecture are different. Sometimes engineers let the TLB as a part of the MMU. some times the TLB and the MMU are indivadual components in the computer architecture.</p>
<h3 id="prerequisite-knowledge">prerequisite knowledge</h3>
<p><strong>physical addresses and virtual addresses</strong><br>
The benefit of using virtual addresses is that it allows management software, such as an Operating System (OS), to control the view of memory that is presented to software. The OS can control what memory is visible, the virtual address at which that memory is visible, and what accesses are permitted to that memory. This allows the OS to sandbox applications (hiding the resources of one application from another application) and to provide abstraction from the underlying hardware.</p>
<p>One benefit of using virtual addresses is that an OS can present multiple fragmented physical regions of memory as a single, contiguous virtual address space to an application.</p>
<p>Virtual addresses also benefit software developers, who will not know a systemâ€™s exact memory addresses when writing their application. With virtual addresses, software developers do not need to concern themselves with the physical memory. The application knows that it is up to the OS and the hardware to work together to perform the address translation.</p>
<p>In practice, each application can use its own set of virtual addresses that will be mapped to different locations in the physical system. As the operating system switches between different applications it re-programs the map. This means that the virtual addresses for the current application will map to the correct physical location in memory.</p>
<p>Virtual addresses are translated to physical addresses through mappings.</p>
<p><strong>page table and page entry</strong><br>
In one word, the page table is a lookup table used by a virtual memory system in a computer operating system to store the mapping between virtual addresses and physical addresses.</p>
<p>The page entry is a structure that holds the mapping between a virtual page and corresponding physical frame, it also contains other information such as a dirty bit or a modified bit.</p>
<h3 id="the-memory-management-unitmmu">The memory management unit(MMU)</h3>
<p>The major component of the MMU is the table walk unit and a very large page table. The table walk unit processes the page table walk operation that find the physical address by the given virtual address the page table.</p>
<p>MMUs also has other control logic to modify the property of PTEs which is pretty significant since such property can guarantee the data is what the processor needs.</p>
<h3 id="implemented-by-simulator">Implemented by simulator</h3>
<p><a href="https://gitlab.com/akita/mem/-/tree/v3/vm/mmu">https://gitlab.com/akita/mem/-/tree/v3/vm/mmu</a><br>
<a href="https://pages.cs.wisc.edu/~swilson/gem5-docs/x86_2tlb_8cc_source.html">https://pages.cs.wisc.edu/~swilson/gem5-docs/x86_2tlb_8cc_source.html</a></p>
<h3 id="reference-useful-links">reference &amp; useful links</h3>
<p><a href="https://developer.arm.com/documentation/101811/0102/The-Memory-Management-Unit--MMU-">https://developer.arm.com/documentation/101811/0102/The-Memory-Management-Unit--MMU-</a><br>
<a href="https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit">https://en.wikipedia.org/wiki/Inputâ€“output_memory_management_unit</a><br>
<a href="https://en.wikipedia.org/wiki/Memory_management_unit">https://en.wikipedia.org/wiki/Memory_management_unit</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git Opeartions]]></title>
        <id>https://DX990307.github.io/post/git-opeartions/</id>
        <link href="https://DX990307.github.io/post/git-opeartions/">
        </link>
        <updated>2023-01-11T10:52:20.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Useful Links<br>
<a href="https://backlog.com/git-tutorial/cn/">https://backlog.com/git-tutorial/cn/</a></li>
<li>Cover local files by files from servers<pre><code>git fetch --all
git reset --hard origin/xxx (the branch that wants to be covered)
git pull
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Useful links]]></title>
        <id>https://DX990307.github.io/post/useful-links/</id>
        <link href="https://DX990307.github.io/post/useful-links/">
        </link>
        <updated>2023-01-08T14:18:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>Git operation<br>
<a href="https://backlog.com/git-tutorial/cn/">https://backlog.com/git-tutorial/cn/</a></p>
</li>
<li>
<p>Pandas<br>
<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html</a></p>
</li>
<li>
<p>Seaborn<br>
<a href="https://seaborn.pydata.org/generated/seaborn.swarmplot.html">https://seaborn.pydata.org/generated/seaborn.swarmplot.html</a></p>
<h2 id="s">S</h2>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://DX990307.github.io/post/hello-gridea/</id>
        <link href="https://DX990307.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="https://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>